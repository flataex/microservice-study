# 4장 트랜잭션 관리 : 사가
## 데이터 일관성 유지: 사가 패턴
- 데이터를 업데이트하는 시스템 커맨드마다 사가를 하나씩 정의합니다.
- 사가는 로컬 트랜잭션마다 변경분을 커밋하므로 보상 트랜잭션을 걸어 롤백해야 합니다.
- 서비스는 로컬 트랜잭션이 완료되면 메시지를 발행하여 다음 사가 단계를 트리거합니다.
- 읽기 전용 단계나, 항상 성공하는 단계 다음에 이어지는 단계는 보상 트랜잭션이 필요 없습니다.

## 사가 편성
#### 코레오그래피
- 시스템 커맨드가 사가를 시작할 때 첫 번째 사가 참여자를 정하여 로컬 트랜잭션 실행을 지시하고, 트랜잭션이 완료되면 그다음 사가 참여자를 호출하는 과정이 모든 단계가 실행될 때까지 반복됩니다.
- 각 참여자는 자신의 DB를 업데이트하고 다음 참여자를 트리 거하는 이 벤트를 발행합니다.
- DB를 업데이트하는 작업과 이벤트를 발행하는 작업은 원자적으로 일어나야 합니다.
- 사가 참여자는 자신이 수신한 이벤트와 자신이 가진 데이터를 연관 지을 수 있어야 합니다.

## 비격리 문제 처리
- 사가의 한 트랜잭션이 커밋한 변경분을 다른 사가가 즉시 바라볼 수 있습니다.
    - 한 사가가 실행 중에 접근하는 데이터를 도중에 다른 사가가 바꿔치기할 수 있습니다.
    - 한 사가가 업데이트를 하기 이전 데이터를 다른 사가가 읽을 수 있어서 데이터 일관성이 깨질 수 있습니다.
- 사가는 일단 주문을 PENDING 상태로 두고 시작합니다. 현재 주문을 사가로 업데이트 하는 중이니 그에 맞게 행동하라고 다른 사가에게 알리는 것입니다.

#### 비격리 대책
- 대책: 시맨틱 락
    - 보상 가능 트랜잭션이 생성/수정하는 레코드에 무조건 플래그를 세팅하는 대책입니다.
    - 레코드가 아직 커밋 전이라서 변경될지 모른다는 표시를 하는 것이죠. (PENDING 상태가 바로 시맨틱 락을 구현한 것입니다.)
- 대책: 교환적 업데이트
    - 어떤 순서로도 실행 가능하게 설계하면 소실된 업데이트 문제를 방지할 수 있습니다.
    - 보상 가능 트랜잭션이 계좌를 인출 후 사가를 롤백시켜야 하는 상황이라면 보상 트랜잭션은 단순히 계좌를 입금해서 업데이트를 언두하면 됩니다.
- 대책: 비관적 관점
    - 더티 읽기로 인한 비즈니스 리스크를 최소화하기 위해 사가 단계의 순서를 재조정하는 것입니다.
    - 주문 생성 사가가 신용 잔고를 더티 읽기해서 소비자 신용 한도를 초과하는 주문을 생성할 위험성을 줄일 수 있습니다.
    1. 주문 서비스: 주문을 취소 상태로 변경합니다.
    2. 배달 서비스: 배달을 취소합니다.
    3. 회계 서비스: 신용 잔고를 늘립니다.
- 대책: 값 다시 읽기
    - 사가가 레코드를 다시 읽기 전에 값을 다시 읽어 값이 변경되지 않았는지 확인하는 것입니다.
    - 값을 다시 읽었더니 변경 되었다면 사가를 중단하고 나중에 재시작합니다.
- 대책: 버전 파일
    - 레코드에 수행한 작업을 하나하나 기록하는 대책입니다.
- 대책: 값에 의한
    - 애플리케이션 차원에서 각 요청의 속성을 보고 사가를 쓸지. 아니면 분산 트랜잭션을 쓸지 판단하는 것이죠.
    - 위험성이 낮은 요청은 지금까지 설명한 대책이 적용된 사가를, 위험성 이 큰 요청은 분산 트랜잭션을 실행합니다.

## 주문 서비스 및 주문 생성 사가 설계
- CreateOrderSaga 사가 오케스트레이터는 사가 참여자 프록시 클래스를 거쳐 사가 참여자에게 커맨드 메 시지를 전달합니다.
- OrderCommandHandlers 클래스는 사가가 주문 서 비스에 전송한 커맨드 메시지를 처리합니다.

#### OrderService 클래스
- OrderService는 Order 를 생성/수정하고. OrderRepository를 호출하여 Order를 저장하며. SagaManager를 이용하여 CreateOrderSaga 같은 사가를 생성합니다.
- SagaManager가 사가 오케스트레이터 인스턴스를 생성하면. 곧 바로 첫 번째 사가 참여자에게 커맨드 메시지가 전달되고 사가 오케스트레이터를 DB에 저장합니다.

#### OrderCommandHandlers 클래스
- 사가가 전송한 커맨드 메시지를 담당할 핸들러 메서드는 OrderCommandHandlers 클래스에 정의합니다
- 핸들러 메서드는 OrderService를 호출하여 주문 업데이트 후 응답 메시지를 생성합니다.

#### 주문 생성 사가 구현
- CreateOrderSaga: 사가의 상태 기계를 정의한 싱글턴 클래스 Create OrderSagaState로 커맨드 메시지를 생성하고, 사가 참여자 프록시 클래스(ex. Kitchen ServiceProxy)가 지정한 메시지 채널을 통해 참여자에게 메시지를 전달합니다.
- CreateOrderSagaState: 사가의 저장 상태. 커맨드 메시지를 생성합니다.
- 사가 참여자 프록시 클래스: 프록시 클래스마다 커맨드 채널. 커맨드 메시지 타입, 반환형으로 구성된 사가 참여자의 메시징 API를 정의합니다.